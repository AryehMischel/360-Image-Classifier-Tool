<!DOCTYPE html>
<html>
<script src="aframe-master.js"></script>
<script src="aframe-html.js"></script>
<script src="https://unpkg.com/aframe-cubemap-component@2.1.1/dist/aframe-cubemap-component.min.js"></script>
<script src="./aframe-stereocam-component.js"></script>
<script src="https://unpkg.com/super-hands@^3.0.3/dist/super-hands.min.js"></script>
<script src="https://unpkg.com/aframe-event-set-component@^4.1.1/dist/aframe-event-set-component.min.js"></script>

<style>
  #draggable {
    width: 150px;
    height: 150px;
    padding: 0.5em;
    resize: both
  }
</style>

<style>
  .mock-file-preview {
    display: inline-block;
    width: 80px;
    /* Set width for the mock preview */
    height: 80px;
    /* Set height for the mock preview */
    background-color: #f0f0f0;
    /* Background color for the mock preview */
    border: 1px solid #ccc;
    /* Border for the mock preview */
    margin: 10px;
    text-align: center;
    line-height: 80px;
    /* Center text vertically */
    font-size: 14px;
    /* Font size for the file name */
  }
</style>
<script src="https://code.jquery.com/jquery-3.7.1.js"></script>
<script src="https://code.jquery.com/ui/1.14.0/jquery-ui.js"></script>
<script>
  $(function () {
    $("#dom-overlay").draggable();
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.9.3/min/dropzone.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
<link rel="stylesheet" href="styles.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.9.3/dropzone.min.css">
<link rel="stylesheet" href="dropzoneStyles.css">
<style>
</style>

<body>
  <a-scene webxr="overlayElement:#dom-overlay;">
    <a-assets>

    </a-assets>

    <a-entity id="user">
      <a-camera stereocam="eye:left;">
        <a-entity id="cursor" class="raycasting" cursor="rayOrigin:mouse" raycaster=""></a-entity>
      </a-camera>
      <a-entity raycaster="objects: .ui" super-hands laser-controls hand-controls="hand: left"></a-entity>
      <a-entity raycaster="objects: .ui" super-hands laser-controls hand-controls="hand: right"></a-entity>
    </a-entity>

    <a-entity id="htmlPanel" shadow position="0.25 1.5 -0.5"></a-entity>


    <a-entity id="cubeMapLayer"></a-entity>

    <a-entity id="stereoCubeMapLayer"></a-entity>

    <a-entity id="eqrtLayer"></a-entity>

    <a-entity id="stereoEqrtLayer"></a-entity>

    <!-- default scene -->
    <a-entity id="layers">
    </a-entity>


  </a-scene>

  <div id="dom-overlay">

    <section id="my-interface">
      <h3>Upload 360 Images</h3>

      <div class="flex-container">

        <button onclick="createQueue()">create queue</button>

        <label for="imgInput" class="uploadImageButton">Select Image Folder</label>
        <!---->
        <button id="npm install dotenv" onclick='handleAuthClick()'>
          <img src="https://ssl.gstatic.com/docs/doclist/images/drive_icon_32.png" alt="Google Drive Logo">
          Import from Google Drive
        </button>

      </div>
      <input class="driveButton" accept="image/png, image/jpeg" style="visibility:hidden;" type="file" id="imgInput"
        webkitdirectory multiple />

      <div id="scrollingButtonContainer">

        <h1>Dropzone.js Example</h1>
        <form class="dropzone" id="my-dropzone"></form>
      </div>
      <div class="win-size-grip"></div>
    </section>
  </div>


</body>

</html>


<!-- dropzone ui and handling image uploads 2.0-->
<script>
  //global variables
  let startedProcessingImageBatch = false;
  var activeImages = new Set();
  var imageNodeUI = {};
  var uploadTrees = [];
  var currentUploadTree = null;
  let imageQueue = [];

  function test(){
    var mockCubeMapFile = { name: "mockCubeMap", size: 12345678, type: "test"};
      myDropzone.emit("addedfile", mockCubeMapFile);
      myDropzone.emit("thumbnail", mockCubeMapFile, "./assets/icons/png-transparent-pink-cross-stroke-ink-brush-pen-red-ink-brush-ink-leave-the-material-text.png");
  }


  // var images = { imageID: { name: "imageName", format: "cubeMap", node: node, texture: threejsTexture} }

  var images = {}

  var cubeMapImageMap = {}


  let cubeMapImageFormat = ["px", "nx", "py", "ny", "pz", "nz"]
  let cubeMapImagesIDs = []
  incrementingID = 0;
  let incrementingFolderID = 1000;
  Dropzone.autoDiscover = false;

  // Define a custom preview template
  const previewTemplate = `
   <div class="dz-preview dz-file-preview">
       <div class="dz-image"><img data-dz-thumbnail /></div>
       <div class="dz-details">
           <div class="dz-size"><span data-dz-size></span></div>
           <div class="dz-filename"><span data-dz-name></span></div>
       </div>
       <!-- Remove the progress bar and other unnecessary elements -->
   </div>
`;

  const myDropzone = new Dropzone("#my-dropzone", {


    url: "/dummy-url", // Provide a dummy URL to satisfy Dropzone's requirement
    addRemoveLinks: true,
    autoProcessQueue: true, // Prevent Dropzone from automatically processing the queue
    previewTemplate: previewTemplate, // Use the custom preview template
    addRemoveLinks: false, // Disable the remove links
    maxThumbnailFilesize: 5, // we will create our own thumbnails in our webworkers and populate them later



    init: function () {



      this.on('complete', function (file) {
        console.log("complete")
      });

      //will handle this manually. this is currently clogging up performance
      this.on("queuecomplete", function () {
        console.log("queue complete")
        createQueue();
        startedProcessingImageBatch = false;
      });



      this.on("addedfile", function (file) {

        if (file.type === "fake") {
          file.previewElement.id = "ui" + file.folderID;
          // console.log(file.folderID, "folderID")
          images[file.folderID] = { "file": file, "format": "cubeMap", "name": "mockCubeMap", "texture": null };
          

          // console.log(images[cubeMapImageMap[file.folderID].get("px")].file)

          let cubeImageBitmaps = []

          async function processCubeMapImages() {
            let cubeImageBitmaps = []
            for (const imageName of cubeMapImageFormat) {
              let subImageFile = images[cubeMapImageMap[file.folderID].get(imageName)].file;
              const bitmap = await createImageBitmap(subImageFile, { imageOrientation: "flipY" });
              cubeImageBitmaps.push(bitmap);
            }
            addIcon(file.folderID, "cubeMapFolder");
            createCubeMapTexture(file.folderID, cubeImageBitmaps);
            addRemove(file.folderID, file)
        
           

          }

          (async () => {
            await processCubeMapImages();

            for (const imageName of cubeMapImageFormat) {
              let subImageFile = images[cubeMapImageMap[file.folderID].get(imageName)].file;
              this.removeFile(subImageFile);
            }

          })();

          return;
        }

       
     
       
        const uniqueId = `${incrementingID++}`;
        if(file.originPoint === "gdrive"){
          if (!startedProcessingImageBatch) {
          startedProcessingImageBatch = true;
          createUploadTree();
        }
          console.log("gdrive file")
        //bypass the file type check
        images[uniqueId] = { "file": file, "format": "unknown", "name": file.name, "texture": null };
        file.previewElement.id = "ui" + uniqueId;
          imageQueue.push({ID: uniqueId});
          processQueue();
          return;
       
        }
        console.log(file.originPoint)
      

        if (!startedProcessingImageBatch) {
          startedProcessingImageBatch = true;
          createUploadTree();
        }
        console.log("added file")




        //make all interactions work off this images object and stop using objects for each format 

        //to-do: remove button when image texture is loaded
        //to-do: add functions to handle removing texture from material

        images[uniqueId] = { "file": file, "format": "unknown", "name": file.name, "texture": null };
        console.log(images[uniqueId])


        file.previewElement.id = "ui" + uniqueId;

        if (file.fullPath) {
          currentUploadTree.addImage(file.fullPath, file.name, uniqueId);

        } else {
          currentUploadTree.addImage(file.fullPath, file.name, uniqueId);
        }

      });

      // Prevent Dropzone from making any network requests
      this.on("sending", function (file, xhr, formData) {
        xhr.abort();

      });

    }
  });




  class ImageNode {
    constructor(name = null, ID = null) {
      this.name = name;
      // this.type = type;
      this.isImage = true;
      // this.file = file;
      this.ID = ID;

    }
  }

  class FolderNode {
    constructor(name) {
      this.name = name;
      this.isImage = false;
      this.children = new Map(); // Use Map for efficient lookups
      this.imageCount = 0; // Initialize imageCount
    }

    addChild(childNode) {
      this.children.set(childNode.name, childNode);
      if (childNode.isImage) {
        this.imageCount++;
      }
    }
  }

  class ImageTree {
    constructor() {
      this.root = new FolderNode("root");
    }

    addImage(relativePath, imageName, imageID) {

      if (relativePath === undefined) {
        const imageNode = new ImageNode(imageName, imageID);
        this.root.addChild(imageNode);
        return;
      }


      let currentNode = this.root;
      const pathParts = relativePath.split('/');

      pathParts.pop(); // Remove the image name from the path

      for (const part of pathParts) {
        let folder = currentNode.children.get(part);
        if (!folder) {
          folder = new FolderNode(part);
          currentNode.addChild(folder);
        }
        currentNode = folder;
      }

      const imageNode = new ImageNode(imageName, imageID);
      currentNode.addChild(imageNode);
    }
  }


  function createUploadTree() {
    console.log("creating new tree")
    let tree = new ImageTree();
    uploadTrees.push(tree);
    currentUploadTree = tree;
    // myDropzone.processQueue();
  }


  // const imageTree = new ImageTree();

  // Function to load an image as a bitmap
  async function loadImageAsBitmap(imageFile) {

    // Create the ImageBitmap

    return bitmap;
  }


  //1. traverse tree and test for cubemap folders / create a queue from the tree

  requiredNamesMap = new Map();
  requiredNamesMap.set("posx", "px");
  requiredNamesMap.set("negx", "nx");
  requiredNamesMap.set("posy", "py");
  requiredNamesMap.set("negy", "ny");
  requiredNamesMap.set("posz", "pz");
  requiredNamesMap.set("negz", "nz");

  console.log(requiredNamesMap.get("px"))

  function createQueue() {
    console.log(currentUploadTree.root.children.size)
    console.log(currentUploadTree.root.children)
    if(currentUploadTree.root.children.size == 0){
      console.log("empty tree")
      return;
    }
    createQueFromTree(currentUploadTree.root, imageQueue);
  }


  function createQueFromTree(node, queue) {
    console.log('creawting')

    if (node.imageCount === 6) {
      console.log("must check for cubemap")
      let folderID = `${incrementingFolderID++}`;
      console.log(folderID, "folderID")

      var imageMap = new Map();

      // imageMap.clear();


      const altRequiredNames = ['posx', 'negx', 'posy', 'negy', 'posz', 'negz'];
      const requiredNames = ['px', 'nx', 'py', 'ny', 'pz', 'nz'];

      let cubeMapImages = []
      cubeMapImagesIDs = []



      for (const child of node.children.values()) {
        if (child.isImage) {

          const baseName = child.name.toLowerCase().split('.')[0];

          if (requiredNames.includes(baseName) & !imageMap.has(baseName)) {
            //valid cubemap image
            imageMap.set(baseName, child.ID);

          } else if (altRequiredNames.includes(baseName) & !imageMap.has(requiredNamesMap.get(baseName))) {
            //valid cubemap image
            console.log(requiredNamesMap.get(baseName))
            imageMap.set(requiredNamesMap.get(baseName), child.ID);

          } else {
            console.log("invalid cubemap image")
          }

          // cubeMapImages.push(child.name)
          // cubeMapImagesIDs.push(child.ID)


        } else {
          createQueFromTree(child, queue);
        }
      }

      cubeMapImageMap[folderID] = imageMap;


      var mockCubeMapFile = { name: "mockCubeMap", size: 12345678, type: "fake", folderID: folderID };
      myDropzone.emit("addedfile", mockCubeMapFile);
      myDropzone.emit("thumbnail", mockCubeMapFile, "./assets/icons/png-transparent-pink-cross-stroke-ink-brush-pen-red-ink-brush-ink-leave-the-material-text.png");
      // const filenames = cubeMapImages.map(image => image.toLowerCase().split('.')[0]);





    }
    else {

      for (const child of node.children.values()) {
        if (child.isImage) {
          console.log("hasn't broken yet? image id is... ", child.ID)
          // while (activeImages.has(child.name)) {
          //   child.name = child.name + "_"
          // }
          // activeImages.add(child.name);
          // imageNodeUI[child.name] = child.uiElementID;

          // addRemove(child.name, child.file)
          queue.push(child);
          processQueue();
        } else {
          createQueFromTree(child, queue);
        }
      }



    }




  }


  const workerCount = 4; // Number of workers in the pool
  const workers = [];
  const workerStatus = new Array(workerCount).fill(false); // Track worker availability


  const messageQueue = [];
  let isProcessingQueue = false;


  // Initialize the worker pool
  for (let i = 0; i < workerCount; i++) {
    const worker = new Worker('worker.js');
    worker.onmessage = async function (e) {

      // Handle the worker response
      console.log(`Worker ${i} has received format`);


      if (e.data.work === "setFormat") {
        console.log("setting format")

        addIcon(e.data.imageID, e.data.format);

        if(e.data.format === "noFormatDetected"){
          addRemove(e.data.imageID, images[e.data.imageID].file)
        }


      } else if (e.data.work === "bitmapGrid") {
        const bitmaps = event.data.bitmapGrid;

        for (const bitmap of bitmaps) {
          console.log("adding")
          const canvas = document.createElement('canvas');
          canvas.width = bitmap.width;
          canvas.height = bitmap.height;
          let myInterface = document.getElementById("my-interface");
          myInterface.appendChild(canvas);

          const ctx = canvas.getContext('2d');
          ctx.drawImage(bitmap, 0, 0);
        }


      }

      else if (e.data.work === "createTexture") {
        images[e.data.imageID].format = e.data.format;
        addRemove(e.data.imageID, images[e.data.imageID].file)

        if (e.data.format === "stereoCubeMap") {
          console.log("workin on eh")
          createStereoCubeMapTexture(e.data.imageID, e.data.bitmaps);
        }


        else if (e.data.format === "eqrt") {
          createEqrtTexture(e.data.imageID, e.data.bitmap);
        }

        else if (e.data.format === "stereoEqrt") {
          createStereoEqrtTexture(e.data.imageID, e.data.bitmaps);
        }


        else if (e.data.format === "cubeMap") {

          createCubeMapTexture(e.data.imageID, e.data.bitmaps);
        }

    

      }    else if(e.data.work === "thumbnail"){
          addImagePreview(e.data.imageID, e.data.thumbnail)
        }



      // Mark the worker as available
      workerStatus[i] = false;

      // Process the next image in the queue
      processQueue();
    };
    workers.push(worker);
  }



  // Function to process the image queue
  function processQueue() {
    if (imageQueue.length > 0) {
      // Find an available worker
      const availableWorkerIndex = workerStatus.findIndex(status => !status);
      if (availableWorkerIndex !== -1) {
        const imageNode = imageQueue.shift();
        let imageObject = images[imageNode.ID];
        workerStatus[availableWorkerIndex] = true; // Mark the worker as busy
        workers[availableWorkerIndex].postMessage({ imageFile: imageObject.file, imageID: imageNode.ID });
      }
    }
  }




  function addIcon(imageID, format) {
    let uiElement = document.getElementById("ui" + imageID).children[0];
    let icon = document.createElement("img");
    icon.src = formatIcons[format];
    icon.style.position = "absolute"; // Ensure the icon is positioned absolutely
    icon.style.zIndex = "1000"; // Ensure the icon is on top
    icon.style.width = "50px";
    icon.style.height = "50px";
    icon.style.top = "0"; // Position the icon at the top
    icon.style.left = "0"; // Position the icon at the left
    uiElement.style.position = "relative"; // Ensure the parent has a positioning context
    uiElement.appendChild(icon);

  }


  function makeUIClickable(imageID) {
    let uiElement = document.getElementById("ui" + uiElementID).children[0];
    uiElement.addEventListener("click", function () {
      console.log("clicked")
    })

  }

  function addRemove(imageID, file) {
    let uiElement = document.getElementById("ui" + imageID);
    let removeButton = document.createElement("button");
    removeButton.onclick = function () {
      event.preventDefault();
      event.stopPropagation();
      console.log("removing")

      //remove texture from material if image texture is on visible material
      if (activeImage === imageID) {
        removeTextureFromMaterial(images[imageID].format)
      }

      // removeFile(file)
      myDropzone.removeFile(file);
      // clear image from images object
      images[imageID] = null;


    }

    removeButton.innerHTML = "remove";
    removeButton.style.position = "absolute"; // Ensure the icon is positioned absolutely
    removeButton.style.zIndex = "1000"; // Ensure the icon is on top
    removeButton.style.width = "50px";
    removeButton.style.height = "50px";
    removeButton.style.top = "0"; // Position the icon at the top
    removeButton.style.right = "0"; // Position the icon at the left
    uiElement.style.position = "relative"; // Ensure the parent has a positioning context
    uiElement.appendChild(removeButton);

  }


  // Add this functionality later when add remove is added at the correct time

  //   function deleteImage2(imageName, format) {
  //     let div = document.getElementById("div" + imageName)
  //     let parent = div.parentNode;
  //     if (imageName === activeImage) {
  //         let index = Array.prototype.indexOf.call(parent.children, div);
  //         if (index === 0) {
  //             if (parent.children.length > 1) {
  //                 parent.children[1].children[0].click()
  //             } else {
  //                 removeTextureFromMaterial(format)
  //             }
  //         } else {
  //             parent.children[index - 1].children[0].click()

  //         }

  //     }
  //     parent.removeChild(div)

  //     // console.log("deleting " + imageName, "from " + format + "Textures")
  //     let command = "delete " + format + "Textures[" + "'" + imageName + "'" + "]"
  //     eval(command)


  // }

  function addImagePreview(imageID, dataURL){
   
    // const bitmap = await createImageBitmap(img);
    myDropzone.emit("thumbnail", images[imageID].file, dataURL);
   
    // const reader = new FileReader();
    // reader.onload = async function(event) {
    //   const imageBitmap = await createImageBitmap(new Blob([event.target.result]));
    //   myDropzone.emit("thumbnail", file, URL.createObjectURL(imageBitmap));
    // };
    // reader.readAsArrayBuffer(file);
    // myDropzone.emit("thumbnail", file, "./assets/icons/png-transparent-pink-cross-stroke-ink-brush-pen-red-ink-brush-ink-leave-the-material-text.png");
  }



</script>
























<script>
  //global variables
  let activeLayer = "eqrtLayer"
  let activeImage = null
  //store all of the 360 images as threejs textures
  var cubeMapTextures = new Object();
  var stereoCubeMapTextures = new Object();
  var eqrtTextures = new Object();
  var stereoEqrtTextures = new Object();

  //each layer represents a different image format type and will have it's own geometry for rendering images.
  // This uses extra geometry for sake of simplicity, but could easily be optimized if performance was a concern.

  let cubeMapLayer = document.getElementById("cubeMapLayer")
  let stereoCubeMapLayer = document.getElementById("stereoCubeMapLayer")
  let eqrtLayer = document.getElementById("eqrtLayer")
  let stereoEqrtLayer = document.getElementById("stereoEqrtLayer")

  let layers_ = {
    "cubeMapLayer": cubeMapLayer,
    "stereoCubeMapLayer": stereoCubeMapLayer,
    "eqrtLayer": eqrtLayer,
    "stereoEqrtLayer": stereoEqrtLayer
  }

  cubeMapLayer.setAttribute("visible", false)
  stereoCubeMapLayer.setAttribute("visible", false)
  stereoEqrtLayer.setAttribute("visible", false)
  eqrtLayer.setAttribute("visible", true)


  const material = new THREE.MeshPhongMaterial();
  material.side = THREE.BackSide

  const skyBoxGeometry = new THREE.BoxGeometry(5000, 5000, 5000);
  const skySphericalGeometry = new THREE.SphereGeometry(30, 64, 32);

  const cubeMaterials = [

    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),


  ];


  // Function to clone materials
  function cloneMaterials(materials) {
    return materials.map(material => material.clone());
  }

  const cubeMaterialsLeftEye = cloneMaterials(cubeMaterials);
  const cubeMaterialsRightEye = cloneMaterials(cubeMaterials);


  // Clone materials for each cubeMesh
  let cubeMesh = new THREE.Mesh(skyBoxGeometry, cubeMaterials);

  let cubeMeshLeftEye = new THREE.Mesh(skyBoxGeometry, cubeMaterialsLeftEye);
  let cubeMeshRightEye = new THREE.Mesh(skyBoxGeometry, cubeMaterialsRightEye);


  let eqrtMesh = new THREE.Mesh(skySphericalGeometry, material);

  let eqrtMeshLeftEye = new THREE.Mesh(skySphericalGeometry, material.clone());
  let eqrtMeshRightEye = new THREE.Mesh(skySphericalGeometry, material.clone());

  cubeMeshLeftEye.layers.set(1)
  cubeMeshRightEye.layers.set(2)

  eqrtMeshLeftEye.layers.set(1)
  eqrtMeshRightEye.layers.set(2)

  cubeMapLayer.object3D.add(cubeMesh)
  stereoCubeMapLayer.object3D.add(cubeMeshLeftEye, cubeMeshRightEye)
  eqrtLayer.object3D.add(eqrtMesh)
  stereoEqrtLayer.object3D.add(eqrtMeshLeftEye, eqrtMeshRightEye)



  function setLayerTexture(imageID) {

    let format = images[imageID].format;
    let texture = images[imageID].texture;

    activeImage = imageID;

    if (format === "cubeMap") {

      for (let i = 0; i < cubeMapLayer.object3D.children[0].material.length; i++) {
        cubeMapLayer.object3D.children[0].material[i].map = texture[i];
        cubeMapLayer.object3D.children[0].material[i].needsUpdate = true;
      }

      if (activeLayer !== "cubeMapLayer") {
        layers_[activeLayer].setAttribute("visible", false);
        cubeMapLayer.setAttribute("visible", true);
        activeLayer = "cubeMapLayer";
      }


    } else if (format === "stereoCubeMap") {

      console.log("setting stereoCubeMap texture")

      for (let i = 0; i < stereoCubeMapLayer.object3D.children[0].material.length; i++) {
        stereoCubeMapLayer.object3D.children[0].material[i].map = texture[0][i];
        stereoCubeMapLayer.object3D.children[0].material[i].needsUpdate = true;
      }

      for (let i = 0; i < stereoCubeMapLayer.object3D.children[1].material.length; i++) {
        stereoCubeMapLayer.object3D.children[1].material[i].map = texture[1][i];
        stereoCubeMapLayer.object3D.children[1].material[i].needsUpdate = true;
      }

      if (activeLayer !== "stereoCubeMapLayer") {
        layers_[activeLayer].setAttribute("visible", false);
        stereoCubeMapLayer.setAttribute("visible", true);
        activeLayer = "stereoCubeMapLayer";
      }

    } else if (format === "eqrt") {

      eqrtLayer.object3D.children[0].material.map = texture;
      eqrtLayer.object3D.children[0].material.needsUpdate = true;

      if (activeLayer !== "eqrtLayer") {
        layers_[activeLayer].setAttribute("visible", false);
        eqrtLayer.setAttribute("visible", true);
        activeLayer = "eqrtLayer";
      }

    } else if (format === "stereoEqrt") {
      stereoEqrtLayer.object3D.children[0].material.map = texture[0];
      stereoEqrtLayer.object3D.children[0].material.needsUpdate = true;
      stereoEqrtLayer.object3D.children[1].material.map = texture[1];
      stereoEqrtLayer.object3D.children[1].material.needsUpdate = true;

      if (activeLayer !== "stereoEqrtLayer") {
        layers_[activeLayer].setAttribute("visible", false);
        stereoEqrtLayer.setAttribute("visible", true);
        activeLayer = "stereoEqrtLayer";
      }

    }







  }

  function removeTextureFromMaterial(format) {

    switch (format) {
      case "cubeMap":
        for (let i = 0; i < cubeMapLayer.object3D.children[0].material.length; i++) {
          cubeMapLayer.object3D.children[0].material[i].map = null;
          cubeMapLayer.object3D.children[0].material[i].needsUpdate = true;
        }
        break;
      case "stereoCubeMap":
        for (let i = 0; i < stereoCubeMapLayer.object3D.children[0].material.length; i++) {
          stereoCubeMapLayer.object3D.children[0].material[i].map = null;
          stereoCubeMapLayer.object3D.children[0].material[i].needsUpdate = true;
        }
        for (let i = 0; i < stereoCubeMapLayer.object3D.children[1].material.length; i++) {
          stereoCubeMapLayer.object3D.children[1].material[i].map = null;
          stereoCubeMapLayer.object3D.children[1].material[i].needsUpdate = true;
        }
        break;
      case "eqrt":
        eqrtLayer.object3D.children[0].material.map = null;
        eqrtLayer.object3D.children[0].material.needsUpdate = true;
        break;
      case "stereoEqrt":
        stereoEqrtLayer.object3D.children[0].material.map = null;
        stereoEqrtLayer.object3D.children[0].material.needsUpdate = true;
        stereoEqrtLayer.object3D.children[1].material.map = null;
        stereoEqrtLayer.object3D.children[1].material.needsUpdate = true;
        break;
    }

  }




  //generate meshes for each 360 format and add to layer




</script>

<script src="./generate360Textures.js"></script>
<script src="./uicontrols.js"></script>

<script src="./imageHandling.js"></script>

<script>

</script>




<!-- the point is to accurately classify images as the following 360 formats-->
<!-- cubemaps (6:1, Horizontal Cross, Reverse Horizontal Cross, Vertical Cross, Horizontal Capital T)-->
<!-- stereocubemaps (12:1, ?)-->
<!-- stereoSpherical (Left:Right,Top:Bottom, ?)-->
<!-- -->
<!-- -->

<script>
  //global variables
  const formatIcons = {
    "cubeMap": "./assets/icons/thickBorderCubeMapLogo.png",
    "stripCubeMap": "./assets/icons/cubeStripThickBorderLogo.png",
    "stereoCubeMap": "./assets/icons/thickBorderStereroCubeMapLogo.png",
    "eqrt": "./assets/icons/globe.png",
    "stereoEqrt": "./assets/icons/stereoGlobe.png",
    "HorizontalCross": "./assets/icons/thickBorderCubeMapLogo.png",
    "HorizontalT": "./assets/icons/thickBorderCubeMapLogo.png",
    "folderCube": "./assets/icons/folder.png",
    "folderCubeMap": "./assets/icons/folder.png",
    "cubeMapFolder": "./assets/icons/folder.png",

    "noFormatDetectedIcon": "./assets/icons/png-transparent-pink-cross-stroke-ink-brush-pen-red-ink-brush-ink-leave-the-material-text.png",
    "noFormatDetected": "./assets/icons/png-transparent-pink-cross-stroke-ink-brush-pen-red-ink-brush-ink-leave-the-material-text.png",

  }


  const scene = document.querySelector("a-scene")
  const renderer = scene.renderer
  var globalImageFiles = new Map()
  var buttonsToEnable = []
  let imagesLoading = 0
  let imagesLoaded = 0
  const initializeTexturesOnLoad = true

  var savedImages = new Set();
  var dir = new Map();




  // upload images
  document.getElementById('imgInput').onchange = async function (e) {
    console.log("loading images")
    var inputDir = $.grep(this.files, function (file) { return file.type.indexOf("image/") === 0; }); // returns flattened array of images in root folder and all folders under root folder
    imagesLoading = inputDir.length   //a counter representing all the images currently loading...
    let dir = unFlattenDir(inputDir) //returns map of directories - each with a nested map of filenames and filedata. example ->  {dir1: {'file1': './assets/images/dir1/file1.png', 'file2': './assets/images/dir1/file2.png'},
    processDir(dir) //process all the images in directories
    e.target.value = '';  //empty input field
  }


  //get image dimensions & and match to image format -> then transform image into 3d object
  function findformat() {

    let imageRatio = Math.round((this.width / this.height) * 10) / 10 // the ratio of the image will indicate the 360 format of the image


    switch (imageRatio) { // width/height
      case 12:
        addFormatIcon(this.name, "stereoCubeMap");
        createStereoCubeMapTexture(this); break;

      case 6:
        addFormatIcon(this.name, "stripCubeMap");
        createCubeStripTexture(this); break;

      case 2:
        addFormatIcon(this.name, "eqrt");
        createEqrtTexture(this); break;

      case 1.3:
        // addFormatIcon(this.name, "cubeMap");
        processCubeMap(this); break;

      case 1: addFormatIcon(this.name, "stereoEqrt"); createStereoEqrtTexture(this); break;
      default:
        //imagesLoading--;
        addFormatIcon(this.name, "noFormatDetectedIcon");
        break;
    }
  }

</script>


<script>
  $(function () {
    $("#dom-overlay").draggable().resizable();
    $("#draggable-iframe").draggable().resizable();
  });


  const allEqual = arr => arr.every(val => val === arr[0]);
</script>

<script>


</script>

<script src="./picker.js"></script>

<script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
<script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>