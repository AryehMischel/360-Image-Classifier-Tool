<!DOCTYPE html>
<html>
<script src="aframe-master.js"></script>
<script src="aframe-html.js"></script>
<script src="https://unpkg.com/aframe-cubemap-component@2.1.1/dist/aframe-cubemap-component.min.js"></script>
<script src="./aframe-stereocam-component.js"></script>
<script src="https://unpkg.com/super-hands@^3.0.3/dist/super-hands.min.js"></script>
<script src="https://unpkg.com/aframe-event-set-component@^4.1.1/dist/aframe-event-set-component.min.js"></script>

<style>
  #draggable {
    width: 150px;
    height: 150px;
    padding: 0.5em;
    resize: both
  }
</style>
<script src="https://code.jquery.com/jquery-3.7.1.js"></script>
<script src="https://code.jquery.com/ui/1.14.0/jquery-ui.js"></script>
<script>
  $(function () {
    $("#dom-overlay").draggable();
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.9.3/min/dropzone.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
<link rel="stylesheet" href="styles.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.9.3/dropzone.min.css">
<style>
    .dropzone {
        border: 2px dashed #0087F7;
        border-radius: 5px;
        background: white;
    }
</style>
<body>
  <a-scene webxr="overlayElement:#dom-overlay;">
    <a-assets>

    </a-assets>

    <a-entity id="user">
      <a-camera stereocam="eye:left;">
        <a-entity id="cursor" class="raycasting" cursor="rayOrigin:mouse" raycaster=""></a-entity>
      </a-camera>
      <a-entity raycaster="objects: .ui" super-hands laser-controls hand-controls="hand: left"></a-entity>
      <a-entity raycaster="objects: .ui" super-hands laser-controls hand-controls="hand: right"></a-entity>
    </a-entity>

    <a-entity id="htmlPanel" shadow position="0.25 1.5 -0.5"></a-entity>


    <a-entity id="cubeMapLayer"></a-entity>

    <a-entity id="stereoCubeMapLayer"></a-entity>

    <a-entity id="eqrtLayer"></a-entity>

    <a-entity id="stereoEqrtLayer"></a-entity>

    <!-- default scene -->
    <a-entity id="layers">
    </a-entity>


  </a-scene>

  <div id="dom-overlay">
    
    <section id="my-interface">
      <h3>Upload 360 Images</h3>

      <div class="flex-container">
       
        <label for="imgInput" class="uploadImageButton">Select Image Folder</label>

        <button id="npm install dotenv" onclick="handleAuthClick()">
          <img src="https://ssl.gstatic.com/docs/doclist/images/drive_icon_32.png" alt="Google Drive Logo">
           Import from Google Drive
        </button>

      </div>
      <input class="driveButton" accept="image/png, image/jpeg" style="visibility:hidden;" type="file" id="imgInput" webkitdirectory multiple />
     
      <div id="scrollingButtonContainer">

        <h1>Dropzone.js Example</h1>
        <form class="dropzone" id="my-dropzone"></form>
      </div>
      <div class="win-size-grip"></div>
    </section>
  </div>


</body>

</html>

<script>

Dropzone.autoDiscover = false;

const myDropzone = new Dropzone("#my-dropzone", {
    url: "/dummy-url", // Provide a dummy URL to satisfy Dropzone's requirement
    addRemoveLinks: true,
    autoProcessQueue: false, // Prevent Dropzone from automatically processing the queue
    init: function () {
        this.on("addedfile", function (file) {
            if (file.fullPath) {
                console.log(file.fullPath);
                 imageTree.addImage(file.fullPath, file.name, "unknown", file);
            } else {
                console.log(file.name);
                imageTree.addImage(file.fullPath, file.name, "unknown", file);
            }
        });

          // Prevent Dropzone from making any network requests
          this.on("sending", function (file, xhr, formData) {
            xhr.abort();
        });
    }
});


  let activeLayer = "eqrtLayer"
  let activeImage = null
  //store all of the 360 images as threejs textures
  var cubeMapTextures = new Object();
  var stereoCubeMapTextures = new Object();
  var eqrtTextures = new Object();
  var stereoEqrtTextures = new Object();

  //each layer represents a different image format type and will have it's own geometry for rendering images.
  // This uses extra geometry for sake of simplicity, but could easily be optimized if performance was a concern.

  let cubeMapLayer = document.getElementById("cubeMapLayer")
  let stereoCubeMapLayer = document.getElementById("stereoCubeMapLayer")
  let eqrtLayer = document.getElementById("eqrtLayer")
  let stereoEqrtLayer = document.getElementById("stereoEqrtLayer")

  let layers_ = {
    "cubeMapLayer": cubeMapLayer,
    "stereoCubeMapLayer": stereoCubeMapLayer,
    "eqrtLayer": eqrtLayer,
    "stereoEqrtLayer": stereoEqrtLayer
  }

  cubeMapLayer.setAttribute("visible", false)
  stereoCubeMapLayer.setAttribute("visible", false)
  stereoEqrtLayer.setAttribute("visible", false)
  eqrtLayer.setAttribute("visible", true)


  const material = new THREE.MeshPhongMaterial();
  material.side = THREE.BackSide

  const skyBoxGeometry = new THREE.BoxGeometry(5000, 5000, 5000);
  const skySphericalGeometry = new THREE.SphereGeometry(30, 64, 32);

  const cubeMaterials = [

    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),


  ];


  // Function to clone materials
  function cloneMaterials(materials) {
    return materials.map(material => material.clone());
  }

  const cubeMaterialsLeftEye = cloneMaterials(cubeMaterials);
  const cubeMaterialsRightEye = cloneMaterials(cubeMaterials);


  // Clone materials for each cubeMesh
  let cubeMesh = new THREE.Mesh(skyBoxGeometry, cubeMaterials);

  let cubeMeshLeftEye = new THREE.Mesh(skyBoxGeometry, cubeMaterialsLeftEye);
  let cubeMeshRightEye = new THREE.Mesh(skyBoxGeometry, cubeMaterialsRightEye);


  let eqrtMesh = new THREE.Mesh(skySphericalGeometry, material);

  let eqrtMeshLeftEye = new THREE.Mesh(skySphericalGeometry, material.clone());
  let eqrtMeshRightEye = new THREE.Mesh(skySphericalGeometry, material.clone());

  cubeMeshLeftEye.layers.set(1)
  cubeMeshRightEye.layers.set(2)

  eqrtMeshLeftEye.layers.set(1)
  eqrtMeshRightEye.layers.set(2)

  cubeMapLayer.object3D.add(cubeMesh)
  stereoCubeMapLayer.object3D.add(cubeMeshLeftEye, cubeMeshRightEye)
  eqrtLayer.object3D.add(eqrtMesh)
  stereoEqrtLayer.object3D.add(eqrtMeshLeftEye, eqrtMeshRightEye)



  function setLayerTexture(texture, format) {
    activeImage = texture

    if (format === "cubeMap") {

      for (let i = 0; i < cubeMapLayer.object3D.children[0].material.length; i++) {
        cubeMapLayer.object3D.children[0].material[i].map = cubeMapTextures[texture][i];
        cubeMapLayer.object3D.children[0].material[i].needsUpdate = true;
      }

      if (activeLayer !== "cubeMapLayer") {
        layers_[activeLayer].setAttribute("visible", false);
        cubeMapLayer.setAttribute("visible", true);
        activeLayer = "cubeMapLayer";
      }


    } else if (format === "stereoCubeMap") {

      for (let i = 0; i < stereoCubeMapLayer.object3D.children[0].material.length; i++) {
        stereoCubeMapLayer.object3D.children[0].material[i].map = stereoCubeMapTextures[texture][0][i];
        stereoCubeMapLayer.object3D.children[0].material[i].needsUpdate = true;
      }

      for (let i = 0; i < stereoCubeMapLayer.object3D.children[1].material.length; i++) {
        stereoCubeMapLayer.object3D.children[1].material[i].map = stereoCubeMapTextures[texture][1][i];
        stereoCubeMapLayer.object3D.children[1].material[i].needsUpdate = true;
      }

      if (activeLayer !== "stereoCubeMapLayer") {
        layers_[activeLayer].setAttribute("visible", false);
        stereoCubeMapLayer.setAttribute("visible", true);
        activeLayer = "stereoCubeMapLayer";
      }

    } else if (format === "eqrt") {

      eqrtLayer.object3D.children[0].material.map = eqrtTextures[texture];
      eqrtLayer.object3D.children[0].material.needsUpdate = true;

      if (activeLayer !== "eqrtLayer") {
        layers_[activeLayer].setAttribute("visible", false);
        eqrtLayer.setAttribute("visible", true);
        activeLayer = "eqrtLayer";
      }

    } else if (format === "stereoEqrt") {
      stereoEqrtLayer.object3D.children[0].material.map = stereoEqrtTextures[texture][0];
      stereoEqrtLayer.object3D.children[0].material.needsUpdate = true;
      stereoEqrtLayer.object3D.children[1].material.map = stereoEqrtTextures[texture][1];
      stereoEqrtLayer.object3D.children[1].material.needsUpdate = true;

      if (activeLayer !== "stereoEqrtLayer") {
        layers_[activeLayer].setAttribute("visible", false);
        stereoEqrtLayer.setAttribute("visible", true);
        activeLayer = "stereoEqrtLayer";
      }

    }







  }

  function removeTextureFromMaterial(format) {

    switch (format) {
      case "cubeMap":
        for (let i = 0; i < cubeMapLayer.object3D.children[0].material.length; i++) {
          cubeMapLayer.object3D.children[0].material[i].map = null;
          cubeMapLayer.object3D.children[0].material[i].needsUpdate = true;
        }
        break;
      case "stereoCubeMap":
        for (let i = 0; i < stereoCubeMapLayer.object3D.children[0].material.length; i++) {
          stereoCubeMapLayer.object3D.children[0].material[i].map = null;
          stereoCubeMapLayer.object3D.children[0].material[i].needsUpdate = true;
        }
        for (let i = 0; i < stereoCubeMapLayer.object3D.children[1].material.length; i++) {
          stereoCubeMapLayer.object3D.children[1].material[i].map = null;
          stereoCubeMapLayer.object3D.children[1].material[i].needsUpdate = true;
        }
        break;
      case "eqrt":
        eqrtLayer.object3D.children[0].material.map = null;
        eqrtLayer.object3D.children[0].material.needsUpdate = true;
        break;
      case "stereoEqrt":
        stereoEqrtLayer.object3D.children[0].material.map = null;
        stereoEqrtLayer.object3D.children[0].material.needsUpdate = true;
        stereoEqrtLayer.object3D.children[1].material.map = null;
        stereoEqrtLayer.object3D.children[1].material.needsUpdate = true;
        break;
    }

  }




  //generate meshes for each 360 format and add to layer




</script>

<script src="./generate360Textures.js"></script>
<script src="./uicontrols.js"></script>

<script src="./imageHandling.js"></script>

<script>

</script>




<!-- the point is to accurately classify images as the following 360 formats-->
<!-- cubemaps (6:1, Horizontal Cross, Reverse Horizontal Cross, Vertical Cross, Horizontal Capital T)-->
<!-- stereocubemaps (12:1, ?)-->
<!-- stereoSpherical (Left:Right,Top:Bottom, ?)-->
<!-- -->
<!-- -->

<script>
  //global variables
  const formatIcons = {
    "cubeMap": "./assets/icons/thickBorderCubeMapLogo.png",
    "stripCubeMap": "./assets/icons/cubeStripThickBorderLogo.png",
    "stereoCubeMap": "./assets/icons/thickBorderStereroCubeMapLogo.png",
    "eqrt": "./assets/icons/globe.png",
    "stereoEqrt": "./assets/icons/stereoGlobe.png",
    "HorizontalCross": "./assets/icons/thickBorderCubeMapLogo.png",
    "HorizontalT": "./assets/icons/thickBorderCubeMapLogo.png",
    "folderCube":    "./assets/icons/folder.png",
    "folderCubeMap": "./assets/icons/folder.png",
    "cubeMapFolder": "./assets/icons/folder.png",

    "noFormatDetectedIcon": "./assets/icons/cubemapLogo.png",
  }


  const scene = document.querySelector("a-scene")
  const renderer = scene.renderer
  var globalImageFiles = new Map()
  var buttonsToEnable = []
  let imagesLoading = 0
  let imagesLoaded = 0
  const initializeTexturesOnLoad = false

  var savedImages = new Set();
  var dir = new Map();




  // upload images
  document.getElementById('imgInput').onchange = async function (e) {
    console.log("loading images")
    var inputDir = $.grep(this.files, function (file) { return file.type.indexOf("image/") === 0; }); // returns flattened array of images in root folder and all folders under root folder
    imagesLoading = inputDir.length   //a counter representing all the images currently loading...
    let dir = unFlattenDir(inputDir) //returns map of directories - each with a nested map of filenames and filedata. example ->  {dir1: {'file1': './assets/images/dir1/file1.png', 'file2': './assets/images/dir1/file2.png'},
    processDir(dir) //process all the images in directories
    e.target.value = '';  //empty input field
  }


  //get image dimensions & and match to image format -> then transform image into 3d object
  function findformat() {

    let imageRatio = Math.round((this.width / this.height) * 10) / 10 // the ratio of the image will indicate the 360 format of the image


    switch (imageRatio) { // width/height
      case 12:
        addFormatIcon(this.name, "stereoCubeMap");
        createStereoCubeMapTexture(this); break;

      case 6:
        addFormatIcon(this.name, "stripCubeMap");
        createCubeStripTexture(this); break;

      case 2:
        addFormatIcon(this.name, "eqrt");
        createEqrtTexture(this); break;

      case 1.3:
        // addFormatIcon(this.name, "cubeMap");
        processCubeMap(this); break;

      case 1: addFormatIcon(this.name, "stereoEqrt"); createStereoEqrtTexture(this); break;
      default:
        //imagesLoading--;
        addFormatIcon(this.name, "noFormatDetectedIcon");
        break;
    }
  }

</script>


<script>
  $(function () {
    $("#dom-overlay").draggable().resizable();
    $("#draggable-iframe").draggable().resizable();
  });


  const allEqual = arr => arr.every(val => val === arr[0]);
</script>

<script>


</script>

<script src="./picker.js"></script>

<script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
<script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>