<!DOCTYPE html>
<html>
<!-- <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script> -->
<script src="aframe-master.js"></script>
<script src="aframe-html.js"></script>
<script src="https://unpkg.com/aframe-cubemap-component@2.1.1/dist/aframe-cubemap-component.min.js"></script>
<script src="./aframe-stereocam-component.js"></script>
<script src="https://unpkg.com/super-hands@^3.0.3/dist/super-hands.min.js"></script>
<script src="https://unpkg.com/aframe-event-set-component@^4.1.1/dist/aframe-event-set-component.min.js"></script>

<style>
  #draggable {
    width: 150px;
    height: 150px;
    padding: 0.5em;
    resize: both
  }
</style>
<script src="https://code.jquery.com/jquery-3.7.1.js"></script>
<script src="https://code.jquery.com/ui/1.14.0/jquery-ui.js"></script>
<script>
  $(function () {
    $("#dom-overlay").draggable();
  });
</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
<link rel="stylesheet" href="styles.css">

<body>
  <a-scene webxr="overlayElement:#dom-overlay;">
    <a-assets>

    </a-assets>

    <!-- <a-box onclick="document.getElementById('imgInput').click()"id="a" position="-1 0.5 -3" rotation="0 45 0" color="red"></a-box> -->

    <a-entity id="user">
      <a-camera stereocam="eye:left;">
        <a-entity id="cursor" class="raycasting" cursor="rayOrigin:mouse" raycaster=""></a-entity>
      </a-camera>
      <a-entity raycaster="objects: .ui" super-hands laser-controls hand-controls="hand: left"></a-entity>
      <a-entity raycaster="objects: .ui" super-hands laser-controls hand-controls="hand: right"></a-entity>
    </a-entity>

    <a-entity id="htmlPanel" shadow position="0.25 1.5 -0.5"></a-entity>


    <a-entity id="cubeMapLayer"></a-entity>

    <a-entity id="stereocubeMapLayer"></a-entity>

    <a-entity id="eqrtLayer"></a-entity>

    <a-entity id="stereoEqrtLayer"></a-entity>

    <!-- default scene -->
    <a-entity id="layers">






    </a-entity>


  </a-scene>
  <!-- style="display: inline-block; background: lavenderblush; color: #333333; border-radius: 1em; padding: 1em; margin:0; accent-color: hotpink;" -->
  <div id="dom-overlay">

    z
    <section id="my-interface">


      <h2>Upload 360 Images</h2>

      <label for="imgInput" class="uploadImageButton">Select Image Folder</label>
      <input class="input" accept="image/png, image/jpeg" style="visibility:hidden;" type="file" id="imgInput"
        webkitdirectory multiple />
      <button id="authorize_button" onclick="handleAuthClick()">Authorize</button>
      <div id="scrollingButtonContainer"></div>
      <div class="win-size-grip"></div>

    </section>
  </div>


</body>

</html>

<script>

  let activeLayer = "eqrtLayer"

  //store all of the 360 images as threejs textures
  var textures = new Object();
  var cubeMapTextures = new Object();
  var stereoCubeTextures = new Object();
  var eqrtTextures = new Object();
  var stereoEqrtTextures = new Object();

  //each layer represents a different image format type and will have it's own geometry for rendering images.
  // This uses extra geometry for sake of simplicity, but could easily be optimized if performance was a concern.

  let cubeMapLayer = document.getElementById("cubeMapLayer")
  let stereocubeMapLayer = document.getElementById("stereocubeMapLayer")
  let eqrtLayer = document.getElementById("eqrtLayer")
  let stereoEqrtLayer = document.getElementById("stereoEqrtLayer")

  let layers_ = {
    "cubeMapLayer": cubeMapLayer,
    "stereocubeMapLayer": stereocubeMapLayer,
    "eqrtLayer": eqrtLayer,
    "stereoEqrtLayer": stereoEqrtLayer
  }

  cubeMapLayer.setAttribute("visible", true)
  stereocubeMapLayer.setAttribute("visible", false)
  stereoEqrtLayer.setAttribute("visible", false)
  eqrtLayer.setAttribute("visible", false)


  const material = new THREE.MeshPhongMaterial();
  material.side = THREE.BackSide

  const skyBoxGeometry = new THREE.BoxGeometry(5000, 5000, 5000);
  const skySphericalGeometry = new THREE.SphereGeometry(30, 64, 32);

  const cubeMaterials = [

    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),

    // new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(c), side: THREE.BackSide }),
    // new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(c2), side: THREE.BackSide }),
    // new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(c3), side: THREE.BackSide }),
    // new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(c4), side: THREE.BackSide }),
    // new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(c5), side: THREE.BackSide }),
    // new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(c6), side: THREE.BackSide }),

  ];





  let cubeMesh = new THREE.Mesh(skyBoxGeometry, cubeMaterials);
  let cubeMeshLeftEye = new THREE.Mesh(skyBoxGeometry);
  let cubeMeshRightEye = new THREE.Mesh(skyBoxGeometry);

  let eqrtMesh = new THREE.Mesh(skySphericalGeometry, material);
  let eqrtMeshLeftEye = new THREE.Mesh(skySphericalGeometry);
  let eqrtMeshRightEye = new THREE.Mesh(skySphericalGeometry);

  cubeMeshLeftEye.layers.set(1)
  cubeMeshRightEye.layers.set(2)
  eqrtMeshLeftEye.layers.set(1)
  eqrtMeshRightEye.layers.set(2)

  cubeMapLayer.object3D.add(cubeMesh)
  stereocubeMapLayer.object3D.add(cubeMeshLeftEye, cubeMeshRightEye)
  eqrtLayer.object3D.add(eqrtMesh)
  stereoEqrtLayer.object3D.add(eqrtMeshLeftEye, eqrtMeshRightEye)



  function setLayerTexture(texture, format) {
    layers_["cubeMapLayer"].object3D.children[0].material.map = texture



    // switch (format) {
    //   case format === activeLayer: console.log("this is the active layer"); break;
    //   case "cubeMap":
    //     // layers_["cubeMapLayer"].object3D
    //     layers_[activeLayer].enabled = false;

    //     layers_["cubeMapLayer"].enabled = true;
    //     break;
    //   case "stereoCubeMap":
    //     cubeMeshLeftEye.material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide }); cubeMeshRightEye.material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide }); break;
    //   case "eqrt":
    //     layers_[format].object3D.children[0].material = [activeLayer].setAttribute("visible", false); break;
    //   case "steroeEqrt": ; break;
    // }


    // eqrtLayer.object3D.children[0].material.map = texture
    // eqrtLayer.object3D.children[0].material.needsUpdate = true;



  }




  //generate meshes for each 360 format and add to layer




</script>

<script src="./generateObjects.js"></script>
<script src="./uicontrols.js"></script>

<script src="./imageHandling.js"></script>

<script>

</script>




<!-- the point is to accurately classify images as the following 360 formats-->
<!-- cubemaps (6:1, Horizontal Cross, Reverse Horizontal Cross, Vertical Cross, Horizontal Capital T)-->
<!-- stereocubemaps (12:1, ?)-->
<!-- stereoSpherical (Left:Right,Top:Bottom, ?)-->
<!-- -->
<!-- -->

<script>
  const formatIcons = {
    "CubeMap": "./cubemapLogo.png",

  }


  const scene = document.querySelector("a-scene")
  const renderer = scene.renderer
  var globalImageFiles = new Map()
  var buttonsToEnable = []
  let imagesLoading = 0
  let imagesLoaded = 0






  //img upload

  document.getElementById('imgInput').onchange = async function (e) {
    disableButtonsWaitForSceneLoad() //disable ui 


    var inputDir = $.grep(this.files, function (file) { return file.type.indexOf("image/") === 0; }); // returns flattened array of images in root folder and all folders under root folder
    imagesLoading = inputDir.length   //a counter representing all the images currently loading...


    let dir = unFlattenDir(inputDir) //returns map of directories - each with a nested map of filenames and filedata. example ->  {dir1: {'file1': './assets/images/dir1/file1.png', 'file2': './assets/images/dir1/file2.png'},
    //                                                                                                                              dir2: {'file1': './assets/images/dir2/file3.png', 'file2': './assets/images/dir2/file4.png'},
    //                                                                                                                               dir3: {'file1': './assets/images/dir3/file1.png', 'file2': './assets/images/dir3/file2.png'} } }

    processDir(dir) //process all the images in directories




  }


  //get image dimensions & and match to image format -> then transform image into 3d object
  function findformat() {

    let ratio = Math.round((this.width / this.height) * 10) / 10 // the ratio of the image will indicate the 360 format of the image
    console.log(ratio)
    let parent = document.createElement("a-entity"); //this object will be the parent of any 3d meshes generated from the current image     
    parent.setAttribute("id", this.name)
    layers.appendChild(parent)

    switch (ratio) {
      case 12: watch(this.name, "stereoCube"); createStereoCubeMapTexture(this, parent); break;
      case 6: watch(this.name, "CubeStrip"); createCubeStripTexture(this, parent); break;
      case 2: watch(this.name, "Sphere"); createEqrtTexture(this, parent); break;
      case 1.3: watch(this.name, "t cubemap"); createCubeMapTexture(this, parent); break;
      case 1: watch(this.name, "stereo spherical"); createStereoEqrtTexture(this, parent); break;
      default: console.log("NA"); imagesLoading--; if (imagesLoaded == imagesLoading) { setupLayers() }; document.getElementById("label" + this.name).innerHTML = "no format detected"
    }
  }



  function watch(name, label) {
    buttonsToEnable.push("button" + name)
    let formatIcon = document.getElementById("label" + name)

    //formatIcon.removeChild(formatIcon.firstChild)
    // icon.setAttribute("style", "background-image: url('path/to/your/image1.png');")
    formatIcon.setAttribute("style", `background-image: url(${formatIcons["CubeMap"]})`)



  }
</script>


<script>
  $(function () {
    $("#dom-overlay").draggable().resizable();
    $("#draggable-iframe").draggable().resizable();
  });


  const allEqual = arr => arr.every(val => val === arr[0]);
</script>

<script>


</script>

<script src="./picker.js"></script>

<script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
<script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>