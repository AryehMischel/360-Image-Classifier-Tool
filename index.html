<!DOCTYPE html>
<html>
<script src="aframe-master.js"></script>
<script src="aframe-html.js"></script>
<script src="https://unpkg.com/aframe-cubemap-component@2.1.1/dist/aframe-cubemap-component.min.js"></script>
<script src="./aframe-stereocam-component.js"></script>
<script src="https://unpkg.com/super-hands@^3.0.3/dist/super-hands.min.js"></script>
<script src="https://unpkg.com/aframe-event-set-component@^4.1.1/dist/aframe-event-set-component.min.js"></script>

<style>
  #draggable {
    width: 150px;
    height: 150px;
    padding: 0.5em;
    resize: both
  }
</style>
<script src="https://code.jquery.com/jquery-3.7.1.js"></script>
<script src="https://code.jquery.com/ui/1.14.0/jquery-ui.js"></script>
<script>
  $(function () {
    $("#dom-overlay").draggable();
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.9.3/min/dropzone.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
<link rel="stylesheet" href="styles.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.9.3/dropzone.min.css">
<link rel="stylesheet" href="dropzoneStyles.css">
<style>
</style>

<body>
  <a-scene webxr="overlayElement:#dom-overlay;">
    <a-assets>

    </a-assets>

    <a-entity id="user">
      <a-camera stereocam="eye:left;">
        <a-entity id="cursor" class="raycasting" cursor="rayOrigin:mouse" raycaster=""></a-entity>
      </a-camera>
      <a-entity raycaster="objects: .ui" super-hands laser-controls hand-controls="hand: left"></a-entity>
      <a-entity raycaster="objects: .ui" super-hands laser-controls hand-controls="hand: right"></a-entity>
    </a-entity>

    <a-entity id="htmlPanel" shadow position="0.25 1.5 -0.5"></a-entity>


    <a-entity id="cubeMapLayer"></a-entity>

    <a-entity id="stereoCubeMapLayer"></a-entity>

    <a-entity id="eqrtLayer"></a-entity>

    <a-entity id="stereoEqrtLayer"></a-entity>

    <!-- default scene -->
    <a-entity id="layers">
    </a-entity>


  </a-scene>

  <div id="dom-overlay">

    <section id="my-interface">
      <h3>Upload 360 Images</h3>

      <div class="flex-container">

        <button onclick="createQueue()">create queue</button>

        <label for="imgInput" class="uploadImageButton">Select Image Folder</label>
        <!---->
        <button id="npm install dotenv" onclick='handleAuthClick()'>
          <img src="https://ssl.gstatic.com/docs/doclist/images/drive_icon_32.png" alt="Google Drive Logo">
          Import from Google Drive
        </button>

      </div>
      <input class="driveButton" accept="image/png, image/jpeg" style="visibility:hidden;" type="file" id="imgInput"
        webkitdirectory multiple />

      <div id="scrollingButtonContainer">

        <h1>Dropzone.js Example</h1>
        <form class="dropzone" id="my-dropzone"></form>
      </div>
      <div class="win-size-grip"></div>
    </section>
  </div>


</body>

</html>


<!-- dropzone ui and handling image uploads 2.0-->
<script>
  //global variables
  var activeImages = new Set();

  var imageNodeUI = {};


  incrementingID = 0;
  Dropzone.autoDiscover = false;

  // Define a custom preview template
  const previewTemplate = `
   <div class="dz-preview dz-file-preview">
       <div class="dz-image"><img data-dz-thumbnail /></div>
       <div class="dz-details">
           <div class="dz-size"><span data-dz-size></span></div>
           <div class="dz-filename"><span data-dz-name></span></div>
       </div>
       <!-- Remove the progress bar and other unnecessary elements -->
   </div>
`;

  const myDropzone = new Dropzone("#my-dropzone", {
    url: "/dummy-url", // Provide a dummy URL to satisfy Dropzone's requirement
    addRemoveLinks: true,
    autoProcessQueue: false, // Prevent Dropzone from automatically processing the queue
    previewTemplate: previewTemplate, // Use the custom preview template
    addRemoveLinks: false, // Disable the remove links
    init: function () {
      this.on("addedfile", function (file) {

        const uniqueId = `${incrementingID++}`;
        file.previewElement.id = uniqueId;
        if (file.fullPath) {
          console.log(file.fullPath);
          imageTree.addImage(file.fullPath, file.name, "unknown", file, uniqueId);
        } else {
          console.log(file.name);
          imageTree.addImage(file.fullPath, file.name, "unknown", file, uniqueId);
        }
      });

      // Prevent Dropzone from making any network requests
      this.on("sending", function (file, xhr, formData) {
        xhr.abort();
      });
    }
  });




  class ImageNode {
    constructor(name, type = null, file = null, uiElementID = null) {
      this.name = name;
      this.type = type;
      this.isImage = true;
      this.file = file;
      this.uiElementID = uiElementID;

    }
  }

  class FolderNode {
    constructor(name) {
      this.name = name;
      this.isImage = false;
      this.children = new Map(); // Use Map for efficient lookups
      this.imageCount = 0; // Initialize imageCount
    }

    addChild(childNode) {
      this.children.set(childNode.name, childNode);
      if (childNode.isImage) {
        this.imageCount++;
      }
    }
  }

  class ImageTree {
    constructor() {
      this.root = new FolderNode("root");
    }

    addImage(relativePath, imageName, type, file, uiElementID) {
      console.log("adding image ", relativePath, imageName, type, uiElementID);

      //make sure to give the imageNode a unique id if it is not a cubemap sub image aka (px, posx, postivex, etc)

      if (relativePath === undefined) {
        console.log("root level")
        const imageNode = new ImageNode(imageName, type, file, uiElementID);
        this.root.addChild(imageNode);
        return;
      }


      let currentNode = this.root;
      const pathParts = relativePath.split('/');

      pathParts.pop(); // Remove the image name from the path

      for (const part of pathParts) {
        let folder = currentNode.children.get(part);
        if (!folder) {
          folder = new FolderNode(part);
          currentNode.addChild(folder);
        }
        currentNode = folder;
      }

      const imageNode = new ImageNode(imageName, type, file, uiElementID);
      currentNode.addChild(imageNode);
    }
  }


  const imageTree = new ImageTree();



  //1. traverse tree and test for cubemap folders / create a queue from the tree
  let imageQueue = [];

  function createQueue() {
    createQueFromTree(imageTree.root, imageQueue);
  }


  function createQueFromTree(node, queue) {


    if (node.imageCount === 6) {
      console.log("must check for cubemap")

    } else {

      for (const child of node.children.values()) {
        if (child.isImage) {
          while (activeImages.has(child.name)) {
            child.name = child.name + "_"

          }

          activeImages.add(child.name);
          imageNodeUI[child.name] = child.uiElementID;
          queue.push(child);
          processQueue();
        } else {
          createQueFromTree(child, queue);
        }
      }

    }

  }


  const workerCount = 4; // Number of workers in the pool
  const workers = [];
  const workerStatus = new Array(workerCount).fill(false); // Track worker availability


const messageQueue = [];
let isProcessingQueue = false;


  // Initialize the worker pool
  for (let i = 0; i < workerCount; i++) {
    const worker = new Worker('worker.js');
    worker.onmessage = async function (e) {

      // Handle the worker response
      console.log(`Worker ${i} has received format`);


      if (e.data.work === "setFormat") {
        console.log("setting format")
        let uiElementID = imageNodeUI[e.data.imageName];
        console.log("ui element id ", uiElementID)
        addIcon(uiElementID, e.data.format);
      
      
      
      } else if (e.data.work === "bitmapGrid") {
        const bitmaps = event.data.bitmapGrid;
     
        for(const bitmap of bitmaps){
          console.log("adding")
          const canvas = document.createElement('canvas');
          canvas.width = bitmap.width;
          canvas.height = bitmap.height;
          let myInterface = document.getElementById("my-interface");
          myInterface.appendChild(canvas);

          const ctx = canvas.getContext('2d');
          ctx.drawImage(bitmap, 0, 0);
        }

     
       
      } 
      
      
      
      else if(e.data.work === "createTexture"){
        if(e.data.format === "stereoCubeMap"){
          console.log("workin on eh")
          let uiElementID = imageNodeUI[e.data.imageName];
          createStereoCubeMapTexture(uiElementID, e.data.bitmaps);
        }
        
        
        else if(e.data.format === "eqrt"){
          let uiElementID = imageNodeUI[e.data.imageName];
          createEqrtTexture(uiElementID, e.data.bitmap);
        }
        
        else if (e.data.format === "stereoEqrt"){
          let uiElementID = imageNodeUI[e.data.imageName];
          createStereoEqrtTexture(uiElementID, e.data.bitmaps);
        }


        else if(e.data.format === "cubeMap"){
          console.log("here")
          let uiElementID = imageNodeUI[e.data.imageName];
          createCubeMapTexture(uiElementID, e.data.bitmaps);
        }
      }


      
      // Mark the worker as available
      workerStatus[i] = false;

      // Process the next image in the queue
      processQueue();
    };
    workers.push(worker);
  }



  // Function to process the image queue
  function processQueue() {
    if (imageQueue.length > 0) {
      // Find an available worker
      const availableWorkerIndex = workerStatus.findIndex(status => !status);
      if (availableWorkerIndex !== -1) {
        const imageNode = imageQueue.shift();
        workerStatus[availableWorkerIndex] = true; // Mark the worker as busy
        workers[availableWorkerIndex].postMessage({ imageFile: imageNode.file, imageName: imageNode.name });
      }
    }
  }




  function addIcon(uiElementID, format) {
    let uiElement = document.getElementById(uiElementID).children[0];
    let icon = document.createElement("img");
    icon.src = formatIcons[format];
    icon.style.position = "absolute"; // Ensure the icon is positioned absolutely
    icon.style.zIndex = "1000"; // Ensure the icon is on top
    icon.style.width = "50px";
    icon.style.height = "50px";
    icon.style.top = "0"; // Position the icon at the top
    icon.style.left = "0"; // Position the icon at the left
    uiElement.style.position = "relative"; // Ensure the parent has a positioning context
    uiElement.appendChild(icon);

  }


  function makeUIClickable(uiElementID) {
    let uiElement = document.getElementById(uiElementID).children[0];
    uiElement.addEventListener("click", function () {
      console.log("clicked")
    })

  }



</script>
























<script>
  //global variables
  let activeLayer = "eqrtLayer"
  let activeImage = null
  //store all of the 360 images as threejs textures
  var cubeMapTextures = new Object();
  var stereoCubeMapTextures = new Object();
  var eqrtTextures = new Object();
  var stereoEqrtTextures = new Object();

  //each layer represents a different image format type and will have it's own geometry for rendering images.
  // This uses extra geometry for sake of simplicity, but could easily be optimized if performance was a concern.

  let cubeMapLayer = document.getElementById("cubeMapLayer")
  let stereoCubeMapLayer = document.getElementById("stereoCubeMapLayer")
  let eqrtLayer = document.getElementById("eqrtLayer")
  let stereoEqrtLayer = document.getElementById("stereoEqrtLayer")

  let layers_ = {
    "cubeMapLayer": cubeMapLayer,
    "stereoCubeMapLayer": stereoCubeMapLayer,
    "eqrtLayer": eqrtLayer,
    "stereoEqrtLayer": stereoEqrtLayer
  }

  cubeMapLayer.setAttribute("visible", false)
  stereoCubeMapLayer.setAttribute("visible", false)
  stereoEqrtLayer.setAttribute("visible", false)
  eqrtLayer.setAttribute("visible", true)


  const material = new THREE.MeshPhongMaterial();
  material.side = THREE.BackSide

  const skyBoxGeometry = new THREE.BoxGeometry(5000, 5000, 5000);
  const skySphericalGeometry = new THREE.SphereGeometry(30, 64, 32);

  const cubeMaterials = [

    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),
    new THREE.MeshBasicMaterial({ side: THREE.BackSide }),


  ];


  // Function to clone materials
  function cloneMaterials(materials) {
    return materials.map(material => material.clone());
  }

  const cubeMaterialsLeftEye = cloneMaterials(cubeMaterials);
  const cubeMaterialsRightEye = cloneMaterials(cubeMaterials);


  // Clone materials for each cubeMesh
  let cubeMesh = new THREE.Mesh(skyBoxGeometry, cubeMaterials);

  let cubeMeshLeftEye = new THREE.Mesh(skyBoxGeometry, cubeMaterialsLeftEye);
  let cubeMeshRightEye = new THREE.Mesh(skyBoxGeometry, cubeMaterialsRightEye);


  let eqrtMesh = new THREE.Mesh(skySphericalGeometry, material);

  let eqrtMeshLeftEye = new THREE.Mesh(skySphericalGeometry, material.clone());
  let eqrtMeshRightEye = new THREE.Mesh(skySphericalGeometry, material.clone());

  cubeMeshLeftEye.layers.set(1)
  cubeMeshRightEye.layers.set(2)

  eqrtMeshLeftEye.layers.set(1)
  eqrtMeshRightEye.layers.set(2)

  cubeMapLayer.object3D.add(cubeMesh)
  stereoCubeMapLayer.object3D.add(cubeMeshLeftEye, cubeMeshRightEye)
  eqrtLayer.object3D.add(eqrtMesh)
  stereoEqrtLayer.object3D.add(eqrtMeshLeftEye, eqrtMeshRightEye)



  function setLayerTexture(texture, format) {

    console.log("setting texture ", texture, format)
    activeImage = texture

    if (format === "cubeMap") {

      for (let i = 0; i < cubeMapLayer.object3D.children[0].material.length; i++) {
        cubeMapLayer.object3D.children[0].material[i].map = cubeMapTextures[texture][i];
        cubeMapLayer.object3D.children[0].material[i].needsUpdate = true;
      }

      if (activeLayer !== "cubeMapLayer") {
        layers_[activeLayer].setAttribute("visible", false);
        cubeMapLayer.setAttribute("visible", true);
        activeLayer = "cubeMapLayer";
      }


    } else if (format === "stereoCubeMap") {

      console.log("setting stereoCubeMap texture")

      for (let i = 0; i < stereoCubeMapLayer.object3D.children[0].material.length; i++) {
        stereoCubeMapLayer.object3D.children[0].material[i].map = stereoCubeMapTextures[texture][0][i];
        stereoCubeMapLayer.object3D.children[0].material[i].needsUpdate = true;
      }

      for (let i = 0; i < stereoCubeMapLayer.object3D.children[1].material.length; i++) {
        stereoCubeMapLayer.object3D.children[1].material[i].map = stereoCubeMapTextures[texture][1][i];
        stereoCubeMapLayer.object3D.children[1].material[i].needsUpdate = true;
      }

      if (activeLayer !== "stereoCubeMapLayer") {
        layers_[activeLayer].setAttribute("visible", false);
        stereoCubeMapLayer.setAttribute("visible", true);
        activeLayer = "stereoCubeMapLayer";
      }

    } else if (format === "eqrt") {

      eqrtLayer.object3D.children[0].material.map = eqrtTextures[texture];
      eqrtLayer.object3D.children[0].material.needsUpdate = true;

      if (activeLayer !== "eqrtLayer") {
        layers_[activeLayer].setAttribute("visible", false);
        eqrtLayer.setAttribute("visible", true);
        activeLayer = "eqrtLayer";
      }

    } else if (format === "stereoEqrt") {
      stereoEqrtLayer.object3D.children[0].material.map = stereoEqrtTextures[texture][0];
      stereoEqrtLayer.object3D.children[0].material.needsUpdate = true;
      stereoEqrtLayer.object3D.children[1].material.map = stereoEqrtTextures[texture][1];
      stereoEqrtLayer.object3D.children[1].material.needsUpdate = true;

      if (activeLayer !== "stereoEqrtLayer") {
        layers_[activeLayer].setAttribute("visible", false);
        stereoEqrtLayer.setAttribute("visible", true);
        activeLayer = "stereoEqrtLayer";
      }

    }







  }

  function removeTextureFromMaterial(format) {

    switch (format) {
      case "cubeMap":
        for (let i = 0; i < cubeMapLayer.object3D.children[0].material.length; i++) {
          cubeMapLayer.object3D.children[0].material[i].map = null;
          cubeMapLayer.object3D.children[0].material[i].needsUpdate = true;
        }
        break;
      case "stereoCubeMap":
        for (let i = 0; i < stereoCubeMapLayer.object3D.children[0].material.length; i++) {
          stereoCubeMapLayer.object3D.children[0].material[i].map = null;
          stereoCubeMapLayer.object3D.children[0].material[i].needsUpdate = true;
        }
        for (let i = 0; i < stereoCubeMapLayer.object3D.children[1].material.length; i++) {
          stereoCubeMapLayer.object3D.children[1].material[i].map = null;
          stereoCubeMapLayer.object3D.children[1].material[i].needsUpdate = true;
        }
        break;
      case "eqrt":
        eqrtLayer.object3D.children[0].material.map = null;
        eqrtLayer.object3D.children[0].material.needsUpdate = true;
        break;
      case "stereoEqrt":
        stereoEqrtLayer.object3D.children[0].material.map = null;
        stereoEqrtLayer.object3D.children[0].material.needsUpdate = true;
        stereoEqrtLayer.object3D.children[1].material.map = null;
        stereoEqrtLayer.object3D.children[1].material.needsUpdate = true;
        break;
    }

  }




  //generate meshes for each 360 format and add to layer




</script>

<script src="./generate360Textures.js"></script>
<script src="./uicontrols.js"></script>

<script src="./imageHandling.js"></script>

<script>

</script>




<!-- the point is to accurately classify images as the following 360 formats-->
<!-- cubemaps (6:1, Horizontal Cross, Reverse Horizontal Cross, Vertical Cross, Horizontal Capital T)-->
<!-- stereocubemaps (12:1, ?)-->
<!-- stereoSpherical (Left:Right,Top:Bottom, ?)-->
<!-- -->
<!-- -->

<script>
  //global variables
  const formatIcons = {
    "cubeMap": "./assets/icons/thickBorderCubeMapLogo.png",
    "stripCubeMap": "./assets/icons/cubeStripThickBorderLogo.png",
    "stereoCubeMap": "./assets/icons/thickBorderStereroCubeMapLogo.png",
    "eqrt": "./assets/icons/globe.png",
    "stereoEqrt": "./assets/icons/stereoGlobe.png",
    "HorizontalCross": "./assets/icons/thickBorderCubeMapLogo.png",
    "HorizontalT": "./assets/icons/thickBorderCubeMapLogo.png",
    "folderCube": "./assets/icons/folder.png",
    "folderCubeMap": "./assets/icons/folder.png",
    "cubeMapFolder": "./assets/icons/folder.png",

    "noFormatDetectedIcon": "./assets/icons/png-transparent-pink-cross-stroke-ink-brush-pen-red-ink-brush-ink-leave-the-material-text.png",
    "noFormatDetected": "./assets/icons/png-transparent-pink-cross-stroke-ink-brush-pen-red-ink-brush-ink-leave-the-material-text.png",

  }


  const scene = document.querySelector("a-scene")
  const renderer = scene.renderer
  var globalImageFiles = new Map()
  var buttonsToEnable = []
  let imagesLoading = 0
  let imagesLoaded = 0
  const initializeTexturesOnLoad = false

  var savedImages = new Set();
  var dir = new Map();




  // upload images
  document.getElementById('imgInput').onchange = async function (e) {
    console.log("loading images")
    var inputDir = $.grep(this.files, function (file) { return file.type.indexOf("image/") === 0; }); // returns flattened array of images in root folder and all folders under root folder
    imagesLoading = inputDir.length   //a counter representing all the images currently loading...
    let dir = unFlattenDir(inputDir) //returns map of directories - each with a nested map of filenames and filedata. example ->  {dir1: {'file1': './assets/images/dir1/file1.png', 'file2': './assets/images/dir1/file2.png'},
    processDir(dir) //process all the images in directories
    e.target.value = '';  //empty input field
  }


  //get image dimensions & and match to image format -> then transform image into 3d object
  function findformat() {

    let imageRatio = Math.round((this.width / this.height) * 10) / 10 // the ratio of the image will indicate the 360 format of the image


    switch (imageRatio) { // width/height
      case 12:
        addFormatIcon(this.name, "stereoCubeMap");
        createStereoCubeMapTexture(this); break;

      case 6:
        addFormatIcon(this.name, "stripCubeMap");
        createCubeStripTexture(this); break;

      case 2:
        addFormatIcon(this.name, "eqrt");
        createEqrtTexture(this); break;

      case 1.3:
        // addFormatIcon(this.name, "cubeMap");
        processCubeMap(this); break;

      case 1: addFormatIcon(this.name, "stereoEqrt"); createStereoEqrtTexture(this); break;
      default:
        //imagesLoading--;
        addFormatIcon(this.name, "noFormatDetectedIcon");
        break;
    }
  }

</script>


<script>
  $(function () {
    $("#dom-overlay").draggable().resizable();
    $("#draggable-iframe").draggable().resizable();
  });


  const allEqual = arr => arr.every(val => val === arr[0]);
</script>

<script>


</script>

<script src="./picker.js"></script>

<script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
<script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>