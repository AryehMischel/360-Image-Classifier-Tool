<!DOCTYPE html>
<html>
<!-- <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script> -->
<script src="aframe-master.js"></script>
<script src="aframe-html.js"></script>
<script src="https://unpkg.com/aframe-cubemap-component@2.1.1/dist/aframe-cubemap-component.min.js"></script>
<script src="./aframe-stereocam-component.js"></script>
<script src="https://unpkg.com/super-hands@^3.0.3/dist/super-hands.min.js"></script>
<script src="https://unpkg.com/aframe-event-set-component@^4.1.1/dist/aframe-event-set-component.min.js"></script>
<script src="https://code.jquery.com/jquery-3.6.0.js"></script>
<script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>

<style>
  body {
    background-color: powderblue;
  }

  /* h1   {color: blue;} */
  p {
    color: red;
  }

  section {

    display: inline-block;
    background: lavenderblush;
    color: #333333;
    border-radius: 1em;
    padding: 1em;
    margin: 0;
    accent-color: hotpink;
    width: 350px;


  }

  .flex-container {
    width: 50px;
    /* or whatever width you want. */
    /* max-width: 50px; */
    min-height: 50px;
    display: flex;
    /* background-color: DodgerBlue; */
  }

  .flex-container>div {
    background-color: #f1f1f1;
    margin: 10px;
    padding: 20px;
    font-size: 30px;
  }

  button {
    min-width: 100px;
    width: 100px;
    /* or whatever width you want. */
    /* // max-width: 50px; */
    /* or whatever width you want. */
    display: inline-block;
    overflow: hidden;
  }


  label {
    display: flex;
    align-items: center;
    padding: 5px;

  }

  .btn {
    background-color: orange;
    display: inline-block;
    color: black;
    border-radius: 1em;
    accent-color: black;
    padding: 1em;
    margin: 0;
    border-style: dashed;
    border-color: black;

  }
</style>

<body>
  <a-scene webxr="overlayElement:#dom-overlay;">
    <a-assets>

    </a-assets>

    <!-- <a-box onclick="document.getElementById('imgInput').click()"id="a" position="-1 0.5 -3" rotation="0 45 0" color="red"></a-box> -->

    <a-entity id="user">
      <a-camera stereocam="eye:left;">
        <a-entity id="cursor" class="raycasting" cursor="rayOrigin:mouse" raycaster=""></a-entity>
      </a-camera>
      <a-entity raycaster="objects: .ui" super-hands laser-controls hand-controls="hand: left"></a-entity>
      <a-entity raycaster="objects: .ui" super-hands laser-controls hand-controls="hand: right"></a-entity>
    </a-entity>

    <a-entity id="htmlPanel" shadow position="0.25 1.5 -0.5"></a-entity>

    <!-- default scene -->
    <a-entity id="layers">




    </a-entity>


  </a-scene>
  <!-- style="display: inline-block; background: lavenderblush; color: #333333; border-radius: 1em; padding: 1em; margin:0; accent-color: hotpink;" -->
  <div id="dom-overlay">
    <section id="my-interface">


      <h2>Upload 360 Images</h2>
      <label for="imgInput" class="btn">Select Image Folder</label>
      <input class="input" style="visibility:hidden;" type="file" id="imgInput" webkitdirectory multiple />
  </div>


</body>

</html>

<script src="./generateObjects.js"></script>
<script src="./uicontrols.js"></script>






<!-- the point is to accurately classify images as the following 360 formats-->
<!-- cubemaps (6:1, Horizontal Cross, Reverse Horizontal Cross, Vertical Cross, Horizontal Capital T)-->
<!-- stereocubemaps (12:1, ?)-->
<!-- stereoSpherical (Left:Right,Top:Bottom, ?)-->
<!-- -->
<!-- -->

<script>
  const scene = document.querySelector("a-scene")
  var globalImageFiles = new Map()
  var buttonsToEnable = []
  let imagesLoading = 0
  let imagesLoaded = 0

  function parseDirectoryHierarchy(flatArray) {
    var dir = new Map();
    for (i = 0; i < flatArray.length; i++) {
      var path = flatArray[i].webkitRelativePath.substring(0, flatArray[i].webkitRelativePath.lastIndexOf("/")) // flatArray[i].webkitRelativePath.substring(flatArray[i].webkitRelativePath.lastIndexOf("/") + 1, flatArray[i].webkitRelativePath.length)
      var file = flatArray[i]//.webkitRelativePath.substring(flatArray[i].webkitRelativePath.lastIndexOf("/") + 1)//);
      var filename = flatArray[i].webkitRelativePath.substring(flatArray[i].webkitRelativePath.lastIndexOf("/") + 1, flatArray[i].webkitRelativePath.lastIndexOf("."))
      //console.log(path)

      if (dir.has(path)) {
        dir.get(path).set(filename, file)
      } else {
        let imgMap = new Map()
        imgMap.set(filename, file)
        dir.set(path, imgMap);//[file]
      }

    }

    return dir

  }


  async function checkCubeMapViable(values) {
    var img = new Image(); //img.parentID = this.files[i].name //this is a little hack that can be removed later
    var img2 = new Image(); //img.parentID = this.files[i].name //this is a little hack that can be removed later
    var img3 = new Image(); //img.parentID = this.files[i].name //this is a little hack that can be removed later
    var img4 = new Image(); //img.parentID = this.files[i].name //this is a little hack that can be removed later
    var img5 = new Image(); //img.parentID = this.files[i].name //this is a little hack that can be removed later
    var img6 = new Image(); //img.parentID = this.files[i].name //this is a little hack that can be removed later

    console.log(Array.from(values.keys())[0])

    var val = values.get(Array.from(values.keys())[0]);
    var val2 = values.get(Array.from(values.keys())[1]);
    var val3 = values.get(Array.from(values.keys())[2]);
    var val4 = values.get(Array.from(values.keys())[3]);
    var val5 = values.get(Array.from(values.keys())[4]);
    var val6 = values.get(Array.from(values.keys())[5]);


    img.src = URL.createObjectURL(val);
    img2.src = URL.createObjectURL(val2);
    img3.src = URL.createObjectURL(val3);
    img4.src = URL.createObjectURL(val4);
    img5.src = URL.createObjectURL(val5);
    img6.src = URL.createObjectURL(val6);


    let images = [img, img2, img3, img4, img5, img6]

    // wait for all images to load

    const proms = images.map(im => new Promise(res =>
      im.onload = () => res(im.width, im.height)
    ))


    //const promise = Promise.resolve();

    // list all image widths and heights _after_ the images have loaded:
    const promise = Promise.all(proms).then(data => {
      console.log(img.width / img.height == 1 && allEqual(data))
      answer = img.width / img.height == 1 && allEqual(data)
      return (answer)
    })

    //IDs = [1, 2, 3] //[promise, "someothershit"]
    return ([promise, images])

    // if (img.width / img.height == 1 && allEqual(data)) {

  }
  //img upload
  document.getElementById('imgInput').onchange = async function (e) {



    var files = this.files;
    imagesLoading = files.length // we check if imagesLoaded == imagesLoading  // change imagesLoading to something like imagesToBeProcessed 

    disableButtonsWaitForSceneLoad() //disable ui untill all images are loaded into the scene. Not strictly necessary 
    let dir = parseDirectoryHierarchy(files)//dir { directory name: imgMap{ imgName: imgFile, etc...}} dir is a map with a nested map -> imgMap


    dir.forEach((values, keys) => {

      console.log(keys, values.size)
      if (values.size == 6) { //check if it is a cubemap

        try {
          let px = URL.createObjectURL(values.get("px"));
          let nx = URL.createObjectURL(values.get("nx"));
          let py = URL.createObjectURL(values.get("py"));
          let ny = URL.createObjectURL(values.get("ny"));
          let pz = URL.createObjectURL(values.get("pz"));
          let nz = URL.createObjectURL(values.get("nz"));
          console.log("proper filenames")
        } catch {

          checkCubeMapViable(values).then((Values) =>{
            Values[0].then((values) =>{
              if(values == true){
                  console.log("cubemap input incurrect")

                  //handle
              } else{
                console.log("simply not a cubemap")
                console.log("lets handle these .." + Values[1])

                //handle

              }
            })
       
          })  //check if valid cubemap
          // let cubeCheck = cubeData[0]
         // console.log(cubeData)
          // console.log(cubeCheck)  


            // else

            // process images that were already created when we tested format


          //cubeCheck.then((value)=>{console.log(value)})
          //   if(value[0] == true){
          //     console.log("data not labeled correctly")
          //   } else{

          //   }

          // })

          // checkCubeMapViable(values).then((value)=>{
          //   if(value[0] == true){
          //     console.log("data not labeled correctly")
          //   } else{

          //   }

          // })
          // console.log("format is .. " + isCubeMapFormat)
        }

        // console.log("cubemaps folder")
        // //make them all into images and compare sizes. if all of equal size and ratio of 1. then log error


        // var img = new Image(); //img.parentID = this.files[i].name //this is a little hack that can be removed later
        // var img2 = new Image(); //img.parentID = this.files[i].name //this is a little hack that can be removed later
        // var img3 = new Image(); //img.parentID = this.files[i].name //this is a little hack that can be removed later
        // var img4 = new Image(); //img.parentID = this.files[i].name //this is a little hack that can be removed later
        // var img5 = new Image(); //img.parentID = this.files[i].name //this is a little hack that can be removed later
        // var img6 = new Image(); //img.parentID = this.files[i].name //this is a little hack that can be removed later

        // console.log(Array.from(values.keys())[0])

        // var val = values.get(Array.from(values.keys())[0]);
        // var val2 = values.get(Array.from(values.keys())[1]);
        // var val3 = values.get(Array.from(values.keys())[2]);
        // var val4 = values.get(Array.from(values.keys())[3]);
        // var val5 = values.get(Array.from(values.keys())[4]);
        // var val6 = values.get(Array.from(values.keys())[5]);


        // img.src = URL.createObjectURL(val);
        // img2.src = URL.createObjectURL(val2);
        // img3.src = URL.createObjectURL(val3);
        // img4.src = URL.createObjectURL(val4);
        // img5.src = URL.createObjectURL(val5);
        // img6.src = URL.createObjectURL(val6);


        // let images = [img, img2, img3, img4, img5, img6]

        // // wait for all images to load

        // const proms = images.map(im => new Promise(res =>
        //   im.onload = () => res(im.width, im.height)
        // ))

        // // list all image widths and heights _after_ the images have loaded:
        // Promise.all(proms).then(data => {
        //   return img.width / img.height == 1 && allEqual(data)
        // })

        // if (img.width / img.height == 1 && allEqual(data)) {

        //   console.log("proper cubemap input")

        //   try {
        //     let px = URL.createObjectURL(values.get("px"));
        //     let nx = URL.createObjectURL(values.get("nx"));
        //     let py = URL.createObjectURL(values.get("py"));
        //     let ny = URL.createObjectURL(values.get("ny"));
        //     let pz = URL.createObjectURL(values.get("pz"));
        //     let nz = URL.createObjectURL(values.get("nz"));
        //     let name = keys
        //     while (activeButtons.has(name)) {
        //       name = name + "_"

        //     }
        //     activeButtons.add(name)
        //     addButton(setLayer, name);
        //     buttonsToEnable.push("button" + name)

        //     let parent = document.createElement("a-entity"); //this object will be the parent of any 3d meshes generated from the current image     
        //     parent.setAttribute("id", name)
        //     imagesLoading = imagesLoading - 5
        //     layers.appendChild(parent)

        //     watch(keys, "folder map")



        //   } catch {
        //     console.log("images not properly formated")
        //   }
        // }

        // })
        //const facesAreProperSquare = img.width/// img.height 

        ///console.log(facesAreProperSquare)


        // const result = allEqual([ [img.width, img.height],[img2.width, img2.height] , [img3.width, img3.height], [img4.width, img4.height], [img5.width, img5.height], [img6.width, img6.height]]) 
        //  createTest(img.src, img2.src, img3.src, img4.src, img5.src, img6.src, parent)

        //         createTest(px.src, nx.src, py.src, ny.src, pz.src, nz.src, parent)
        // img.onload = findformat // find the 360 format that best fits this image 
        // let px = URL.createObjectURL(values.get("px"));
        // let nx = URL.createObjectURL(values.get("nx"));
        // let py = URL.createObjectURL(values.get("py"));
        // let ny = URL.createObjectURL(values.get("ny"));
        // let pz = URL.createObjectURL(values.get("pz"));
        // let nz = URL.createObjectURL(values.get("nz"));
        // activeButtons.add(name)
        // addButton(setLayer, name);
        // buttonsToEnable.push("button" + name)

        // let parent = document.createElement("a-entity"); //this object will be the parent of any 3d meshes generated from the current image     
        // parent.setAttribute("id", name)
        // imagesLoading = imagesLoading - 5
        // // layers.appendChild(parent)

        // // watch(keys, "folder map")
        // createTest(px, nx, py, ny, pz, nz, parent)
        // } 

        //catch {
        //   console.log("aint a valid cubemap")
        //   values.forEach((values, keys) => {

        //     var img = new Image(); //img.parentID = this.files[i].name //this is a little hack that can be removed later

        //     img.name = values.name  //generate id for parent object, current bug when dealing with duplicate image names

        //     while (activeButtons.has(img.name)) {
        //       img.name = img.name + "_"

        //     }

        //     globalImageFiles.set(img.name, values)
        //     activeButtons.add(img.name)


        //     img.src = URL.createObjectURL(values);
        //     img.onload = findformat // find the 360 format that best fits this image 

        //     addButton(setLayer, img.name); // buttonsToEnable.push("button" + img.name); //add button to ui

        //   })

        // }



      } else {

        values.forEach((values, keys) => {

          processImage(values)

        })

      }


    });

    dir = null
    flatArray = null
    files = null


    //   for (let i = files.length; i < files.length; i++) { //let i = 0 
    //     var img = new Image(); //img.parentID = this.files[i].name //this is a little hack that can be removed later

    //     img.name = this.files[i].name  //generate id for parent object, current bug when dealing with duplicate image names

    //        while(activeButtons.has(img.name)) {
    //         img.name = img.name + "_"

    //       }

    //       activeButtons.add(img.name)


    //     img.src = URL.createObjectURL(this.files[i]);
    //     img.onload = findformat // find the 360 format that best fits this image 

    //     addButton(setLayer, img.name); // buttonsToEnable.push("button" + img.name); //add button to ui

    //   }
  }

  function processImage(values) {

    var img = new Image(); //img.parentID = this.files[i].name //this is a little hack that can be removed later

    img.name = values.name  //generate id for parent object, current bug when dealing with duplicate image names

    while (activeButtons.has(img.name)) {
      img.name = img.name + "_"

    }

    globalImageFiles.set(img.name, values)
    activeButtons.add(img.name)


    img.src = URL.createObjectURL(values);
    img.onload = findformat // find the 360 format that best fits this image 

    addButton(setLayer, img.name); // buttonsToEnable.push("button" + img.name); //add button to ui

  }




  function printActiveImages() {
    globalImageFiles.forEach((value, key) => {
      console.log(value.name)
    })
  }


  function roughSizeOfObject(object) {
    const objectList = [];
    const stack = [object];
    let bytes = 0;

    while (stack.length) {
      const value = stack.pop();

      switch (typeof value) {
        case 'boolean':
          bytes += 4;
          break;
        case 'string':
          bytes += value.length * 2;
          break;
        case 'number':
          bytes += 8;
          break;
        case 'object':
          if (!objectList.includes(value)) {
            objectList.push(value);
            for (const prop in value) {
              if (value.hasOwnProperty(prop)) {
                stack.push(value[prop]);
              }
            }
          }
          break;
      }
    }

    return bytes;
  }

  //get image dimensions & and match to image format -> then transform image into 3d object
  function findformat() {
    let ratio = Math.round((this.width / this.height) * 10) / 10 // the ratio of the image will indicate the 360 format of the image

    let parent = document.createElement("a-entity"); //this object will be the parent of any 3d meshes generated from the current image     
    parent.setAttribute("id", this.name)
    layers.appendChild(parent)

    switch (ratio) {
      case 12: watch(this.name, "stereoCube"); createStereoCube(this, parent); break;
      case 6: watch(this.name, "CubeStrip"); processCubeStrip(this, parent); break;
      case 2: watch(this.name, "Sphere"); createSphere(this, parent); break;
      case 1.3: watch(this.name, "t cubemap"); processCubeMap(this, parent); break;
      case 1: watch(this.name, "stereo spherical"); createStereoSphere(this, parent); break;
      default: console.log("NA"); imagesLoading--; if (imagesLoaded == imagesLoading) { setupLayers() }; document.getElementById("label" + this.name).innerHTML = "no format detected"
    }
  }


  function watch(name, label) {
    buttonsToEnable.push("button" + name)
    document.getElementById("label" + name).innerHTML = label

  }



  function reformatTest(id) {
    let p = document.getElementById(id)
    for (let i = 0; i < p.object3D.children.length; i++) {
      p.object3D.remove(p.object3D.children[i])
    }

    console.log(globalImageFiles.get(id))

    var img = new Image(); //img.parentID = this.files[i].name //this is a little hack that can be removed later
    img.src = URL.createObjectURL(globalImageFiles.get(id));

    img.onload = createSphere(img, p) // find the 360 format that best fits this image 
  }

</script>


<script>
  $(function () {
    $("#dom-overlay ").draggable();
  });
  const allEqual = arr => arr.every(val => val === arr[0]);
</script>